<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="toolTipSavePython.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>494, 44</value>
  </metadata>
  <data name="button_export.ToolTip" xml:space="preserve">
    <value>Pressing this button you will perform these actions at once:

-  save a .py file that contains functions that, once executed 
   in Python, will create a Chrono::Engine system.

-  create a directory for saving 'assets', that are the shapes
   for rendering and visualization, that can be used in C::E
   postprocessing. Shapes are saved in the directory in .OBJ
   format.</value>
  </data>
  <data name="checkBox_surfaces.ToolTip" xml:space="preserve">
    <value>If turned ON, the a xxxyyy_shapes directory will be created in the same 
place where you save the xxxyyy.py file. This directory will contain the
triangle meshes representing the visualization shapes of the parts.
All shapes are save separately as Wavefront .OBJ files.

The xxxyyy.py file will contain the statements to link those OBJ files
to the ChBody objects in the system, so you can easily render animations
using the Chrono::Engine post processing unit.</value>
  </data>
  <data name="checkBox_collshapes.ToolTip" xml:space="preserve">
    <value>  The generated xxxyyy.py file will contain statements that define
collision shapes for the ChBody parts. 

  Collision shapes must be created in SolidWorks, by creating 'solid bodies' 
in SolidEdge parts, for example a rod part can contain two cylinder and a
box solid bodies, approximating the collision geometry of the rod. 

  Each collision shape must be previously marked using the 
 'Set body as collision shape' button.</value>
  </data>
  <data name="checkBox_constraints.ToolTip" xml:space="preserve">
    <value>If turned ON, the .py exported file will contain also
the statements that create Chrono::Engine constraints 
between the parts.
Most basic 'mate' constraints in SolidWorks are translated
into Chrono::Engine constraints of ChLinkMate type; but
some advanced SolidWorks constraints might not be
translated.</value>
  </data>
  <data name="button_setcollshape.ToolTip" xml:space="preserve">
    <value>To use this function: 
- create a part with multiple 'bodies', one is the shape of 
   the part (for mass, visualization, etc.), the others are simple
   spheres or cubes or cylinders that optionally define the 
   collision shapes; these bodies can overlap (do not use the
   join or fuse when creating them)
- select one of the bodies that you want to use as a collision
   shape,
- press this button.
The body should change colour to mean that it now it represent
a collision shape (and won't enter into mass computation or
tesselation for visualization meshes).
If the selected body cannot be used as a collision shape, an 
error message will pop up.</value>
  </data>
  <data name="checkBox_separateobj.ToolTip" xml:space="preserve">
    <value>A part or a subsassebly in SolidWorks, that will be converted to 
a single Chrono::Engine rigid body, can consist of multiple
closed surfaces, for instance a 'wheel' subassembly can have
surfaces for bolts, screws, etc. If this button is checked, all
those surfaces will be saved separately in different .obj files. 
if not checked, surfaces will be saved in a single .obj, that will
correspond to the entire Chrono::Engine rigid body.
If you plan to modify/texture/edit the .obj files, maybe that
one option or the other can be more confortable to you.

</value>
  </data>
  <data name="checkBox_saveUV.ToolTip" xml:space="preserve">
    <value>If checked, the .OBJ files that contain the geometry of the shapes will also
contain the UV coordinates for UV texture mapping.
The UV coordinates are defaults generated by SolidWorks: maybe that you need 
to modify them if you do some advanced texture mapping afterward,
for example editing/modifying/texturing the generated OBJ files using
some other 3d modeling software.</value>
  </data>
  <data name="checkBox_savetest.ToolTip" xml:space="preserve">
    <value>If checked, a test Python program is saved along with your files,
in the same directory.
This Python program, if executed, will load your .py file and
will dump some files that can be used in POV for raytracing 
an animation.</value>
  </data>
  <data name="button_convexdecomp.ToolTip" xml:space="preserve">
    <value>To use this function: 
- select a solid body in a part,
- press this button.
The shape of the object will be converted in many convex 
shapes that will be used for collision detection.
The convex decomposition process is often an approximation
of the original shape, and depends a lot on the parameters; so 
when it is possible, it is better to create the collision shapes by 
hand by using compounds of cylinders, spheres, etc. 
</value>
  </data>
  <data name="button_chrono_property.ToolTip" xml:space="preserve">
    <value>This button opens a window where you can 
set Chrono::Engine specific properties.
To set ChBody specific properties (friction ,etc.) 
- select a part in an assembly,
- press this button.
Note that many properties used by Chrono::Engine,
such as mass properties, coordinates, grounded/floating
state, etc., are taken directly from SolidWorks properties
of the part.</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>25</value>
  </metadata>
  <data name="$this.ToolTip" xml:space="preserve">
    <value>It can happen that a single SolidWorks part or subassembly, that will
be converted to a single Chrono::Engine rigid body, could contain multiple
separate shapes. For example a wheel can contain bolts, screws, etc.
- if this button is checked,  .obj files is generated per each separable surface
   in each Chrono::Engine rigid body,
- if this button is not checked, a single .obj file is generated per each 
   Chrono::Engine rigid body.
The former or the latter option can be more confortable depending on 
how you plan to modify/edit/texture the .obj files. </value>
  </data>
</root>